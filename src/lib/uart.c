/**
 *@ingroup lib
 *@defgroup uart Software UART API
 *@{
 *@file
 *****************************************************************************
 * A software based half-duplex uart API inspired from AVR 304.
 * The Tx pin uses a regular I/O pin and the timer 0.
 * The Rx pin uses a level interrupt and the timer 0.
 *
 * The code should cope with bit rate up to 56700 for clocks of 8MHz and up.
 * Some #error would warn if the baud rate was not compatible with the 
 *  MPU speed.
 * 
 * @requires SYS_CLOCK
 *
 * @author software@arreckx.com
 *****************************************************************************
 */

#include "wgx.h"
#include "dbg.h"
#include "uart.h"

#ifdef AVR

// This part defines low level functions

/* ---------------------------------------------------------------------------
 *   Defines and sanity checks
 */

#if !defined(SYS_CLOCK)
#  error "System clock must defined in SYS_CLOCK"
#elif !defined(UART_BAUD)
#  define UART_BAUD 19200
#endif

/**
 * Overhead in cycles taken by the interrupt before the timer value is modified
 * This value was obtained from having a look at the machine code generated by
 *  the compiler. It corresponds to the time taken by the first interrupt to
 *  arm the timer and the time taken by the sampling interrupt to read the bit
 * Although this delay is also applied when transmitting, it only means that
 *  all the transmission bits will be delayed by this amount of cycles.
 */
#define UART_OVERHEAD 90

// Work out the prescaler value such that the output compare value fits within
// 16-bits. 
// 
// Values are for clock up to 20MHz (max allowed on the AVR Tiny).
#if (SYS_CLOCK*115/UART_BAUD/10 - UART_OVERHEAD) < 65536
   #define UART_TIMER_PRESCALE_VALUE 1
   #define PRESCALE_MSK   _BV(CS00)
#elif (SYS_CLOCK*115/UART_BAUD/80 - UART_OVERHEAD) < 65536
   #define UART_TIMER_PRESCALE_VALUE 8
   #define PRESCALE_MSK   _BV(CS01)
#elif (SYS_CLOCK*115/UART_BAUD/640 - UART_OVERHEAD) < 65536
   #define UART_TIMER_PRESCALE_VALUE 64
   #define PRESCALE_MSK   _BV(CS01) | _BV(CS00)
#else
   #error "Baud rate too slow or clock too fast"
#endif

// Check the rate is not too fast
#if (SYS_CLOCK/UART_BAUD) < 64
   #error "Baud rate too fast, or clock too slow"
#endif

/** Helper macro for working the time sampling time */
#define UART_TIMER_COUNT_AT(n) (uint16_t)((SYS_CLOCK*(1.5+n))/UART_BAUD/UART_TIMER_PRESCALE_VALUE - UART_OVERHEAD )


/* ---------------------------------------------------------------------------
 *   Types
 */

/**  Enumeration holding software UART's state */
typedef enum
{
   /** Idle state, both transmit and receive possible */
   uartIdle_e,
   /** Transmitting byte */
   uartTx_e,          
   /** Transmitting start bit */
   uartTxStartBit_e, 
   /** Transmitting stop bit */
   uartTxStopBit_e,
   /** Receiving incomming byte */
   uartRx_e,       
   /** Receiving stop bit */
   uartRxStopBit_e,
   /** Data has been received and is ready to collect */
   uartDataPending_e,
} uartState_t;


/* ---------------------------------------------------------------------------
 *   Data
 */

/** Hold the state of the uart */
static volatile uartState_t uartState;

/** Holds the data received or to be transmitted */
static volatile uint8_t uartTxData;

/** Hold data the was received. -1 indicates a error */
static volatile int uartRxData;

/** Index of the bit currently been processed */
static volatile uint8_t uartIndexBitIndex;

/** Called immediatly after a bit has been detected to stop other interrupts */
static uartShutdownCallback_t uartCallback;

/** First timer compare value set at 1.5 to sample the rx bit */
static const uint16_t uartInitialTimerCount = UART_TIMER_COUNT_AT(0);


//
//  Hookup with the stdio library
//
#ifdef HOOK_UART_TO_STDIN
   /** Setup standard stream */
   static int uartPutChar(char c, FILE *stream);

   /** Create a steam to assign to stdout */
   static FILE serialout = FDEV_SETUP_STREAM(uartPutChar, NULL, _FDEV_SETUP_WRITE);
#endif


/** Table with next timer compare value for Rx'ing or Tx'ing bits */
const uint16_t PROGMEM aBitTime[] = 
{
   UART_TIMER_COUNT_AT(1),  // 0 - Rx=b0   - Tx=start
   UART_TIMER_COUNT_AT(2),  // 1 - Rx=b1   - Tx=b0
   UART_TIMER_COUNT_AT(3),  // 2 - Rx=b2   - Tx=b1
   UART_TIMER_COUNT_AT(4),  // 3 - Rx=b3   - Tx=b2
   UART_TIMER_COUNT_AT(5),  // 4 - Rx=b4   - Tx=b3
   UART_TIMER_COUNT_AT(6),  // 5 - Rx=b5   - Tx=b4
   UART_TIMER_COUNT_AT(7),  // 6 - Rx=b6   - Tx=b5
   UART_TIMER_COUNT_AT(8),  // 7 - Rx=b7   - Tx=b6
   UART_TIMER_COUNT_AT(9),  // 8 - Rx=stop - Tx=b7
   UART_TIMER_COUNT_AT(10), // 9 - Rx=-    - Tx=stop
   0                        // 10 - reset to 0
};


/** Start the timer0 clock */
static inline void uartStartTimer(void) 
{
   // Clear pending interrupt on the timer
   TIFR = _BV(OCF0A);

   // Reset the prescaler and start the timer
   TCCR0B = _BV(PSR0) | PRESCALE_MSK; 
}

/** Stop the uart sampling timer */
static inline void uartStopTimer(void)
{ 
   TCCR0B = _BV(TSM);    

   // Clear pending interrupt on the timer
   TIFR = _BV(OCF0A);
}

/** Enable the pin change interrupt */
static inline void uartEnablePinChangeInterrupt(void)
{
   // Clear pending pcint interrupt
   GIFR = _BV(PCIF);

   // Unmask the PCINT
   PCMSK_OF(UART_RX_PORT) |= _BV(UART_RX_BIT);
}

/** Disable the pin change interrupt */
static inline void uartDisablePinChangeInterrupt(void)
{ 
   PCMSK_OF(UART_RX_PORT) &= ~_BV(UART_RX_BIT); 

   // Clear pending pcint interrupt if the bit waggles
   GIFR = _BV(PCIF);
}

/** Set the uart Tx pin, according the polarity */
static inline void uartSetTxPin(void)
#if UART_TX_POL == 0
   { UART_TX_PORT |= _BV(UART_TX_BIT); }
#else
   { UART_TX_PORT &= ~_BV(UART_TX_BIT); }
#endif

/** Clear the uart Tx pin, according the polarity */
static inline void uartClearTxPin(void)
#if UART_TX_POL == 0
   { UART_TX_PORT &= ~_BV(UART_TX_BIT); }
#else
   { UART_TX_PORT |= _BV(UART_TX_BIT); }
#endif

static inline bool uartIsRxPinClear(void)
   { return bit_is_clear( PIN_OF(UART_RX_PORT), UART_RX_BIT ); }

static inline bool uartIsRxPinSet(void)
   { return bit_is_set( PIN_OF(UART_RX_PORT), UART_RX_BIT ); }

static inline void uartResetTimerCount(void)
   { TCNT0H = 0; TCNT0L = 0; }

static inline void setNextTimerCompare( uint16_t compareValue )
   { OCR0B = (uint8_t)((compareValue) >> 8); OCR0A = (uint8_t)(compareValue); }


/** 
 * Initialise the UART API and make the serial port the stdout stream.
 *
 * @param callback  This callback will be invoke upon receiving a valid
 *         character, atomically from an interrupt (nexted interrupts 
 *         turned off) and should shutdown all other interrupts in the
 *         system to avoid un-acceptable jitter during the receive phase.
 *        Once the character has been received, it is up to the callee to 
 *         resume normal operations.
 *        Can be NULL so no callback is made.
 */
void uartInit( uartShutdownCallback_t callback )
{
   // Reset the uartState
   uartState = uartIdle_e;

   // Store the callback
   uartCallback = callback;

#ifdef HOOK_UART_TO_STDIN
   // Make this serial port the default stdout
   stdout = &serialout;
#endif

   // Configure the Tx pin as an output
   DDR_OF(UART_TX_PORT) |= _BV(UART_TX_BIT);

   // Configure the Rx with pull up for the cases where the port is left unconnected
   UART_RX_PORT |= _BV(UART_RX_BIT);

   // Set the Tx pin idle
   uartSetTxPin();

   // Set the pin change mask to enable the interrupt on the Rx pin
   PCMSK0 = PCMSK1 = 0;

   // Enable PCINT interrupts
   if ( UART_RX_BIT >= PORT0 && UART_RX_BIT < PORT4 && &UART_RX_PORT==&PORTB )
   {
      GIMSK |= _BV( PCIE0 );
   }
   else
   {
      GIMSK |= _BV( PCIE1 );
   }

   // Keep the timer halted
   uartStopTimer();

   // Configure timer0 in straigh 16-bit mode
   TCCR0A = _BV(TCW0);

   // Clear pending interrupt on the timer
   TIFR |= _BV(OCF0A);

   // Enable the compare interrupt
   TIMSK |= _BV(OCIE0A);

   // Enable interrupts globally
   sei();

   // Unmask the PCINT
   uartEnablePinChangeInterrupt();
}


/**
 * Sends a character down the Tx pin.
 * This method relies on the timer 0 interrupt to send all bits,
 *  including start and stop bits.
 *
 * @pre initUart must be called in advance.
 *
 * @param  c   Byte to transmit.
 */
void uartTransmit( const uint8_t c )
{
   // Stop incomming characters - this will also clear pending interrupts
   uartDisablePinChangeInterrupt();

   //
   // Wait for any ongoing rx or tx to complete
   //

   // Stop any pending interrupts to atomically read the uartState
   cli();

   // Check to see if a char is available
   while( uartState != uartIdle_e )
   {
      // Re-enable interrupts and wait. 
      // The sleep is guaranteed to be exectued before any interrupts
      sei();
      sleep_mode();
      cli();
   }
   
   uartState = uartTxStartBit_e;
  
   // Store the character to transmit
   uartTxData = c;

   // Reset bit count
   uartIndexBitIndex = 0;

   // Set the next compare at the 1st cycle so we can use the same table as Rx
   setNextTimerCompare( uartInitialTimerCount );

   // Reset the timer
   uartResetTimerCount();

   // Restart the timer which will transmit all bits
   uartStartTimer();

   // Re-enable interrupts
   sei();
}


#ifdef HOOK_UART_TO_STDIN
/**
 * Hook function to hook the uart to stdout
 * Insert carriage returns with line feeds.
 *
 * @param c     Character to send
 * @param FILE  Unused.
 * @return 0 always.
 */
static int uartPutChar(char c, FILE *stream)
{
   if (c == '\n')
   {
      uartPutChar('\r', stream);
   }

   uartSendChar(c);

   return 0;
}
#endif


/** 
 * Allow the caller to check whether a character is being or
 *  has been received
 * @return true if yes
 */
bool uartHasChar(void)
{
   // Atomically read into a register
   register uartState_t state = uartState;

   return state == uartRx_e || state == uartRxStopBit_e || state == uartDataPending_e;
}


/**
 * Wait for a character to come. This function will block until
 *  a character has been received.
 *
 * @return The received character
 */
int uartGetChar(void)
{
   set_sleep_mode(0);

   // Stop any pending interrupts
   cli();

   // Check to see if a char is available
   while ( uartState != uartDataPending_e )
   {
      // Re-enable interrupts and wait. 
      // The sleep is guaranteed to be exectued before any interrupts
      sei();
      sleep_mode();
      cli();
   }

   // Re-enable interrupts. A new rx may happen but it will take many cycles
   //  before the rx buffer is altered
   sei();

   // Clear the state
   uartState = uartIdle_e;

   return uartRxData;
}


/**
 * Serves the interrupt where the the Rx Pin changes state
 */
ISR( PCINT_vect )
{
   if ( uartIsRxPinClear() )
   {
      dbgSet(DBG_UART);

      // Disable this interrupt
      uartDisablePinChangeInterrupt();

      // Reset the timer0
      uartResetTimerCount();

      // Set the next compare at 1 1/2 cycle
      setNextTimerCompare( uartInitialTimerCount );

      // Start the timer0 clock
      uartStartTimer();

      // Change state to rx
      uartState = uartRx_e;

      // Next bit to read
      uartIndexBitIndex = 0;

      // Reset the data
      uartRxData = 0;

      // Stop all other interrupts in the system
      if ( uartCallback != NULL )
      {
         uartCallback();
      }

      dbgClear(DBG_UART);
   }
}


/**
 * The compare interrupt is used to send or sample the next bit.
 */
ISR(TIMER0_COMPA_vect)
{
   dbgSet(DBG_UART);

   // Set next compare value in all cases
   setNextTimerCompare( pgm_read_word( &aBitTime[uartIndexBitIndex] ) );

   switch( uartState )
   {
   case uartTxStartBit_e:
      // Create a start bit
      uartClearTxPin();

      // Next state to tranmit data bits
      uartState = uartTx_e;
   break;

   case uartTx_e:
      if ( uartIndexBitIndex < 9 )
      {
         if ( uartTxData & 0x01 )
         {
            uartSetTxPin();
         }
         else
         {
            uartClearTxPin();
         }

         uartTxData >>= 1;
      }
      else
      {
          // Send the stop bit
         uartSetTxPin();
         uartState = uartTxStopBit_e;
      }
   break;

   case uartTxStopBit_e:
      uartStopTimer();
      uartState = uartIdle_e;
      uartEnablePinChangeInterrupt();
   break;

   case uartRx_e:
      // Count one period after the falling edge is trigged.

      if( uartIndexBitIndex < 8 )
      {
         // Shift due to receiving LSB first.
         uartRxData >>= 1;

         if( uartIsRxPinSet() ) 
         {
            // If a logical 1 is read, let the data mirror this
            uartRxData |= 0x80;
         }
      }
      else
      {
         // Check the stop bit
         if( uartIsRxPinClear() ) 
         {
            // Framing error
            uartRxData = -1;
         }

         // Enter data pending once the whole byte has been received.
         uartState = uartDataPending_e;               

         // No more bits to sample
         uartStopTimer();

         // Prepare for next byte
         uartEnablePinChangeInterrupt();
      }
   break;

   
   default:        
      // Error, should not occur. Going to a safe state.
      uartState = uartIdle_e;
   }

   // Move to next bit in all cases
   ++uartIndexBitIndex;

   dbgClear(DBG_UART);
}

#endif // def AVR

//----------------------------------------------------------------------------
// Common function
// Can be used by the simulation
//----------------------------------------------------------------------------


/** 
 * Tranmit an ascii character.
 * Sending a '\n' will send a '\r' too.
 * For binary transmittion, use the uartTransmit instead
 *
 * @param c Character to transmit
 */
void uartSendChar( const unsigned char c )
{
   uartTransmit(c);

   if ( c == '\n' )
   {
      uartTransmit('\r');
   }
}

/**
 * Prints the string to the uart as is.
 * No carriage return is appended.
 *
 * @param str  A string stored in program memory
 * @see uartPrintln
 */
void uartPrint( PGM_P str )
{
   unsigned char c;

   while ( (c = pgm_read_byte(str)) != '\0' )
   {
      uartSendChar(c);
      ++str;
   }
}


/**
 * Prints the string to the uart and send a line feed and carriage return
 *
 * @param str  A string stored in program memory
 */
void uartPrintln( PGM_P str )
{
   uartPrint(str);
   uartSendChar('\n');
}


/**
 * Prints a number to the uart.
 * This method does not require any buffer and thus saves stack.
 * @param n Number to print
 * @param digits Number of digits for the number to have. This is the same as the %n value
 *          used with printf. If set to -1, trailing zeros are added everywhere.
 */
void uartPrintNumber( int n, int digits )
{
   uint16_t div = 10000;
   uint8_t pos = 5;

   if ( n < 0 ) 
   {
      uartSendChar('-');
      n = -n;
   }

   while ( div > 0 )
   {
      char d = n/div;
      n -= d*div;
      div /= 10;

      if ( d > 0 || div==0 || digits < 0  )
      {
         uartSendChar( d + '0');
         digits = -1;
      }
      else if ( digits > --pos )
      {
         uartSendChar( ' ' );
      }
   }
}


/* ----------------------------  End of file  ---------------------------- */
